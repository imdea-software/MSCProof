//! Sumcheck Protocol for multilinear extension
//! File taken from arkworks mlsumcheck library and modified to fit our needs

use crate::data_structures::{ListOfProductsOfPolynomials, PolynomialInfo};

use crate::ipformlsumcheck::prover::ProverMsg;
use crate::ipformlsumcheck::prover::ProverState;

use crate::ipformlsumcheck::verifier::SubClaim;
use crate::ipformlsumcheck::IPForMLSumcheck;

use ark_linear_sumcheck::Error;

use ark_linear_sumcheck::rng::{Blake2s512Rng, FeedableRNG};

use ark_ff::Field;
use ark_std::marker::PhantomData;
use ark_std::vec::Vec;

// Sumcheck for products of multilinear polynomial
pub struct MLSC<F: Field>(#[doc(hidden)] PhantomData<F>);

/// proof generated by prover
pub type Proof<F> = Vec<ProverMsg<F>>;

impl<F: Field> MLSC<F> {
    // generate proof of the sum of polynomial over {0,1}^`num_vars`
    //
    // The polynomial is represented by a list of products of polynomials along with its coefficient that is meant to be added together.
    //
    // This data structure of the polynomial is a list of list of `(coefficient, DenseMultilinearExtension)`.
    // * Number of products n = `polynomial.products.len()`,
    // * Number of multiplicands of ith product m_i = `polynomial.products[i].1.len()`,
    // * Coefficient of ith product c_i = `polynomial.products[i].0`
    //
    // The resulting polynomial is
    //
    // $$\sum_{i=0}^{n}C_i\cdot\prod_{j=0}^{m_i}P_{ij}$$

    pub fn prove(
        polynomial: &ListOfProductsOfPolynomials<F>,
        rng: &mut Blake2s512Rng,
    ) -> Result<(Proof<F>, ProverState<F>), Error> {

        let mut prover_state = IPForMLSumcheck::prover_init(&polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for r in 0..polynomial.num_variables {
            let (prover_msg, prover_state_new) =
                IPForMLSumcheck::prove_round(prover_state, &verifier_msg);

            prover_state = prover_state_new;
            rng.feed(&prover_msg)?;
            prover_msgs.push(prover_msg);
            if r != polynomial.num_variables - 1 {
                let ri = IPForMLSumcheck::sample_round(rng);
                verifier_msg = Some(ri);
            }
        }

        Ok((prover_msgs, prover_state))
    }

    // verify the claimed sum using the proof
    pub fn verify(
        polynomial_info: &PolynomialInfo,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<SubClaim<F>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(polynomial_info)?;
        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);

        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.get(i).expect("proof is incomplete");
            fs_rng.feed(prover_msg)?;
            let result =
                IPForMLSumcheck::verify_round((*prover_msg).clone(), verifier_state, &mut fs_rng);
            verifier_state = result.1;
        }

        Ok(IPForMLSumcheck::check_and_generate_subclaim(
            verifier_state,
            claimed_sum,
        )?)
    }
}
